---
title: "Expo Router Setup"
description: "Learn how to use the routing system in BuildWithAI+ boilerplate"
---

# Routing with Expo Router

The BuildWithAI+ boilerplate uses [Expo Router](https://docs.expo.dev/routing/introduction/) for navigation. Expo Router is a file-based routing solution for React Native that brings the simplicity of web routing to native apps, while preserving the native feel and performance.

## Routing Structure

The routing system is organized as a file-based router where each file in the `app` directory becomes a route in your application:

```
app/
├── (auth)/
│   ├── sign-in.tsx
│   ├── sign-up.tsx
│   └── _layout.tsx
├── (main)/
│   ├── home.tsx
│   ├── profile.tsx
│   ├── settings/
│   │   ├── index.tsx
│   │   ├── notifications.tsx
│   │   └── _layout.tsx
│   └── _layout.tsx
├── _layout.tsx
└── index.tsx
```

## Route Groups

The boilerplate uses route groups (indicated by parentheses) to organize routes logically:

- `(auth)`: Authentication-related screens that are accessible when the user is not logged in
- `(main)`: Main application screens accessible after authentication
- `(modals)`: Modal screens that can appear over other screens

Route groups allow you to:
- Apply shared layouts to specific sections of your app
- Create logical boundaries between different parts of your app
- Control access based on authentication state

## Understanding Layouts

Layouts in Expo Router are defined using `_layout` files and provide structure to your screens:

```jsx
// app/(main)/_layout.tsx
import { Stack } from 'expo-router';

export default function MainLayout() {
  return (
    <Stack>
      <Stack.Screen
        name="home"
        options={{
          title: 'Home',
        }}
      />
      <Stack.Screen
        name="profile"
        options={{
          title: 'Profile',
        }}
      />
    </Stack>
  );
}
```

The boilerplate includes several pre-configured layouts:

1. **Root Layout** (`app/_layout.tsx`): The entry point that includes providers and handles initial auth state
2. **Auth Layout** (`app/(auth)/_layout.tsx`): Handles authentication screens
3. **Main Layout** (`app/(main)/_layout.tsx`): Contains the main app navigation
4. **Modal Layout** (`app/(modals)/_layout.tsx`): Configures how modals appear

## Navigation Types

The boilerplate supports multiple navigation types through Expo Router:

### Stack Navigation

```jsx
import { useRouter } from 'expo-router';

function MyScreen() {
  const router = useRouter();
  
  const goToProfile = () => {
    router.push('/(main)/profile');
  };
  
  return (
    <Button onPress={goToProfile}>Go to Profile</Button>
  );
}
```

### Tab Navigation

The main app uses a tab navigator defined in the main layout:

```jsx
// app/(main)/_layout.tsx
import { Tabs } from 'expo-router';
import { HomeIcon, UserIcon, SettingsIcon } from '@/components/icons';

export default function MainLayout() {
  return (
    <Tabs>
      <Tabs.Screen
        name="home"
        options={{
          title: 'Home',
          tabBarIcon: ({ color }) => <HomeIcon color={color} />
        }}
      />
      <Tabs.Screen
        name="profile"
        options={{
          title: 'Profile',
          tabBarIcon: ({ color }) => <UserIcon color={color} />
        }}
      />
      <Tabs.Screen
        name="settings"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color }) => <SettingsIcon color={color} />
        }}
      />
    </Tabs>
  );
}
```

### Modal Navigation

For modal screens, use the `/(modals)` route group:

```jsx
router.push('/(modals)/select-option');
```

## Authentication Flow

The boilerplate includes a pre-configured authentication flow:

1. The root layout contains an auth provider that checks if the user is logged in
2. Based on authentication state, users are directed to either `(auth)` or `(main)` routes
3. Protected routes are automatically handled by the auth provider

```jsx
// app/_layout.tsx (simplified)
import { useAuth } from '@/hooks/useAuth';
import { Redirect, Stack } from 'expo-router';

export default function RootLayout() {
  const { isAuthenticated, isLoading } = useAuth();
  
  if (isLoading) return <LoadingScreen />;
  
  if (!isAuthenticated) {
    return <Redirect href="/(auth)/sign-in" />;
  }
  
  return (
    <Stack>
      {/* Screens */}
    </Stack>
  );
}
```

## Dynamic Routes

For dynamic routes like item details, create a file with square brackets:

```
app/(main)/items/[id].tsx
```

Then access the parameter:

```jsx
import { useLocalSearchParams } from 'expo-router';

export default function ItemScreen() {
  const { id } = useLocalSearchParams();
  return <Text>Item ID: {id}</Text>;
}
```

## Deep Linking

The boilerplate comes with deep linking pre-configured. To test deep links:

```bash
# iOS
npx uri-scheme open exp://localhost:8081/--/items/123 --ios

# Android
npx uri-scheme open exp://localhost:8081/--/items/123 --android
```

For production apps, configure your app's scheme in `app.json`:

```json
{
  "expo": {
    "scheme": "buildwithai"
  }
}
```

This allows deep links like `buildwithai://items/123` to work.

## Best Practices

1. **Organize by feature**: Group related screens in directories
2. **Use consistent naming**: Maintain a clear naming convention for routes
3. **Keep layouts simple**: Avoid complex logic in layout files
4. **Leverage TypeScript**: Define types for route parameters
5. **Handle authentication**: Use the auth provider for protected routes
6. **Optimize transitions**: Configure appropriate transition animations

## Next Steps

- Learn how to [Add New Screens](/development/routing/adding-screens) to your app
- Configure [Deep Linking](/development/routing/deep-linking) for external access
- Explore more advanced routing patterns in the [Expo Router documentation](https://docs.expo.dev/routing/introduction/)
